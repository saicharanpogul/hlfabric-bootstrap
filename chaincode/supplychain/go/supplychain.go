package main

import (
	"encoding/json"
	"fmt"
	"github.com/hyperledger/fabric-contract-api-go/contractapi"
)

// ServerConfig for external chaincode
type ServerConfig struct {
	CCID string
	Address string
}

// SmartContract provides functions for managing supply chain
type SmartContract struct {
	contractapi.Contract
}

// CertTrack tracks the certificate
type CertTrack struct {
	Hash string `json:"hash"`
	Holder string `json:"holder"`
	DateTime string `json:"dateTime"`
	ModifiedDateTime string `json:"modifiedDateTime"`
	URL string `json:"url"`
	Status string `json:"status"`
}

// 	Example: CertTrack {
// 		Hash: "bb93506a38348a6b0b7f7f71466ef1f3",
// 		Holder: "Shipper",
// 		DateTime: "10-02-2021 08:30:00 PM",
// 		ModifiedDateTime: "10-02-2021 08:30:00 PM",
// 		URL: "https://supplychain-01.s3.amazonaws.com/409c101d-b926-425f-a8c8-c06bcf19cc4f.pdf",
// 		Status: "Certificate generated by shipper1"
// }

// QueryCertTrack struct used for handling results of query
type QueryCertTrack struct {
	CertID string `json:"certId"`
	Cert *CertTrack
}

// AddCert can be called by any member to add certs
func (s *SmartContract) AddCert(ctx contractapi.TransactionContextInterface, certID string, hash string, holder string, dateTime string, url string, status string)  error {

	certTrack := CertTrack {
		Hash: hash,
		Holder: holder,
		DateTime: dateTime,
		ModifiedDateTime: dateTime,
		URL: url,
		Status: status,
	}

	certTrackAsBytes, _ := json.Marshal(certTrack)

	return ctx.GetStub().PutState(certID, certTrackAsBytes)
}

// GetCertByID can be called by any member of channel
func (s *SmartContract) GetCertByID(ctx contractapi.TransactionContextInterface, certID string) (*CertTrack, error) {

	certTrackAsBytes, err := ctx.GetStub().GetState(certID)

	if err != nil {
		return nil, fmt.Errorf("Failed to read from world state, %s", err.Error())
	}

	if certTrackAsBytes == nil {
		return nil, fmt.Errorf("%s does not exist", certID)
	}

	certTrack := new(CertTrack)
	_ = json.Unmarshal(certTrackAsBytes, certTrack)

	return certTrack, nil
}

// TransferCert can be called by members to change the holder of cert
func (s *SmartContract) TransferCert(ctx contractapi.TransactionContextInterface, certID string, currentHolder string, newHolder string, modifiedDateTime string, status string) (*CertTrack, error) {

	certTrack, err := s.GetCertByID(ctx, certID)

	if err != nil {
		return nil, err
	}

	if certTrack.Holder != currentHolder {
		return nil, fmt.Errorf("You have to be certificate holder to transfer. Current Holder is: %s", certTrack.Holder)
	}

	certTrack.Holder = newHolder
	certTrack.ModifiedDateTime = modifiedDateTime
	certTrack.Status = status

	certTrackAsBytes, _ := json.Marshal(certTrack)

	return certTrack, ctx.GetStub().PutState(certID, certTrackAsBytes)
}

// ChangeStatus can be called by memers to change the status of the cert
func (s *SmartContract) ChangeStatus(ctx contractapi.TransactionContextInterface, certID string, status string, modifiedDateTime string) (*CertTrack, error) {

	certTrack, err := s.GetCertByID(ctx, certID)

	if err != nil {
		return nil, err
	}

	certTrack.Status = status
	certTrack.ModifiedDateTime = modifiedDateTime

	certTrackAsBytes, _ := json.Marshal(certTrack)

	return certTrack, ctx.GetStub().PutState(certID, certTrackAsBytes)
}

// GetAllCerts is called to query all available certs on ledger
func (s *SmartContract) GetAllCerts(ctx contractapi.TransactionContextInterface) ([]QueryCertTrack, error) {
	startKey := ""
	endKey := ""

	resultsIterator, err := ctx.GetStub().GetStateByRange(startKey, endKey)

	if err != nil {
		return nil, err
	}

	defer resultsIterator.Close()

	results := []QueryCertTrack{}

	for resultsIterator.HasNext() {
		queryResponse, err := resultsIterator.Next()

		if err != nil {
			return nil, err
		}

		certTrack := new(CertTrack)

		_ = json.Unmarshal(queryResponse.Value, certTrack)

		queryCertTrack := QueryCertTrack{
			CertID: queryResponse.Key,
			Cert: certTrack,
		}

		results = append(results, queryCertTrack)
	}

	return results, nil
}

func main() {
	smartContract := new(SmartContract)

	chaincode, err := contractapi.NewChaincode(smartContract)

	if err != nil {
		panic(err.Error())
	}

	if err := chaincode.Start(); err != nil {
		panic(err.Error())
	}
}